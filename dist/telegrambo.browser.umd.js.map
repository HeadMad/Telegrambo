{"version":3,"file":"telegrambo.browser.umd.js","sources":["../utils/browserRequestSenderAsync.js","../src/eventContextPayload.js","../src/EventContext.js","../utils/createHandlerStorage.js","../src/errors.js","../src/BotContext.js","../src/browserBotAsync.js","../utils/browserRequestSenderSync.js","../src/browserBotSync.js"],"sourcesContent":["import RequestPayloadPrepare from \"./requestPayloadPrepare.js\";\r\n\r\nexport default BrowserRequestSenderAsync;\r\n\r\nfunction createRequestSender(token, { timeout = 30000, apiUrl = 'https://api.telegram.org' } = {}) {\r\n  if (!token || typeof token !== 'string') \r\n    throw new Error('Token must be a non-empty string');\r\n\r\n  return async function requestSender(method, payload = {}) {\r\n    if (!method || typeof method !== 'string') \r\n      throw new Error('Method must be a non-empty string');\r\n\r\n    const url = `${apiUrl}/bot${token}/${method}`;\r\n    const payloadEntries = Object.entries(payload);\r\n    \r\n    const hasFiles = payloadEntries.some(([key, value]) => {\r\n      if (isFile(value)) return true;\r\n      if (key === 'media' && Array.isArray(value)) {\r\n        return value.some(item => isFile(item?.media));\r\n      }\r\n      return false;\r\n    });\r\n\r\n    const request = hasFiles \r\n      ? buildMultipart(payloadEntries) \r\n      : buildJSON(RequestPayloadPrepare(payloadEntries));\r\n\r\n    return sendRequest(url, request, timeout);\r\n  };\r\n}\r\n\r\nfunction isFile(value) {\r\n  if (!value || typeof value !== 'object') return false;\r\n  return value instanceof Blob || \r\n         value instanceof File ||\r\n         (value.source && (value.source instanceof Blob || value.source instanceof File));\r\n}\r\n\r\nfunction buildJSON(payload) {\r\n  return {\r\n    body: JSON.stringify(payload),\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    }\r\n  };\r\n}\r\n\r\nfunction buildMultipart(payloadEntries) {\r\n  const formData = new FormData();\r\n  const files = [];\r\n  let fileIndex = 0;\r\n\r\n  function processValue(key, value) {\r\n    if (isFile(value)) {\r\n      const name = `file${fileIndex++}`;\r\n      const file = value instanceof Blob || value instanceof File ? value : value.source;\r\n      const filename = value.filename || (value instanceof File ? value.name : 'file');\r\n      files.push({ name, file, filename });\r\n      return `attach://${name}`;\r\n    }\r\n    \r\n    if (key === 'media' && Array.isArray(value)) {\r\n      return value.map(item => {\r\n        if (item && typeof item === 'object' && isFile(item.media)) {\r\n          const name = `file${fileIndex++}`;\r\n          const file = item.media instanceof Blob || item.media instanceof File \r\n            ? item.media \r\n            : item.media.source;\r\n          const filename = item.media.filename || (item.media instanceof File ? item.media.name : 'file');\r\n          files.push({ name, file, filename });\r\n          return { ...item, media: `attach://${name}` };\r\n        }\r\n        return item;\r\n      });\r\n    }\r\n    \r\n    return value;\r\n  }\r\n\r\n  for (const [key, value] of payloadEntries) {\r\n    const processedValue = processValue(key, value);\r\n    const fieldValue = typeof processedValue === 'object' && processedValue !== null\r\n      ? JSON.stringify(processedValue)\r\n      : String(processedValue);\r\n    \r\n    formData.append(key, fieldValue);\r\n  }\r\n\r\n  for (const { name, file, filename } of files) {\r\n    formData.append(name, file, filename);\r\n  }\r\n\r\n  return {\r\n    body: formData,\r\n    headers: {}\r\n  };\r\n}\r\n\r\nasync function sendRequest(url, { body, headers }, timeout) {\r\n  const controller = new AbortController();\r\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n\r\n  try {\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers,\r\n      body,\r\n      signal: controller.signal\r\n    });\r\n\r\n    clearTimeout(timeoutId);\r\n    const data = await response.json();\r\n\r\n    if (data.ok) {\r\n      return data.result;\r\n    }\r\n    \r\n    const error = new Error(data.description || 'API Error');\r\n    error.code = data.error_code;\r\n    throw error;\r\n  } catch (error) {\r\n    clearTimeout(timeoutId);\r\n    \r\n    if (error.name === 'AbortError') {\r\n      throw new Error('Request timeout');\r\n    }\r\n    \r\n    throw error;\r\n  }\r\n}\r\n","const ContextDataEvents = new Map();\r\n\r\n// Incomming messages\r\nContextDataEvents.set('message', event => ({\r\n    chat_id: event.chat.id,\r\n    from_chat_id: event.chat.id,\r\n    message_id: event.message_id,\r\n    message_thread_id: event?.message_thread_id,\r\n    direct_messages_topic_id: event?.direct_messages_topic?.topic_id\r\n}));\r\n\r\n// Обработчик для бизнесс аккаунта\r\nconst businessHandler = event => ({\r\n  business_connection_id: event.business_connection_id,\r\n  chat_id: event.chat.id,\r\n  message_id: event.message_id\r\n});\r\n\r\nContextDataEvents.set('business_message', businessHandler);\r\nContextDataEvents.set('edited_business_message', businessHandler);\r\nContextDataEvents.set('deleted_business_messages', businessHandler);\r\n\r\nContextDataEvents.set('business_connection', event => ({\r\n  chat_id: event.user_chat_id,\r\n  // business_connection_id: event.id\r\n}));\r\n\r\n\r\n// request of pushed inline button\r\nContextDataEvents.set('callback_query', event => ({\r\n  chat_id: event.message.chat.id,\r\n  callback_query_id: event.id,\r\n  message_id: event.message.message_id\r\n}));\r\n\r\n\r\nContextDataEvents.set('inline_query', event => ({\r\n  inline_query_id: event.id\r\n}));\r\n\r\n// Post to channel\r\nContextDataEvents.set('channel_post', event => ({\r\n  chat_id: event.chat.id,\r\n  message_id: event.message_id\r\n}));\r\n\r\n// Voited in poll\r\nContextDataEvents.set('poll_answer', event => ({\r\n  chat_id: 'user' in event ? event.user.id : event.voter_chat.id\r\n}));\r\n\r\n// Запрос на  вступление в чат\r\nContextDataEvents.set('chat_join_request', event => ({\r\n  chat_id: event.from.id\r\n}));\r\n\r\n// Чат получил boost\r\nContextDataEvents.set('chat_boost', event => ({\r\n  chat_id: event.boost.source.user.id\r\n}));\r\n\r\n// Пользователь удалил boost\r\nContextDataEvents.set('removed_chat_boost', event => ({\r\n  chat_id: event.source.user.id\r\n}));\r\n\r\n\r\nexport default eventContextPayload;\r\n\r\n\r\n/**\r\n * Generates the payload for a given event context.\r\n *\r\n * @param {string} eventName - The name of the event.\r\n * @param {any} eventData - The data associated with the event.\r\n * @return {object} The payload for the event context.\r\n */\r\nfunction eventContextPayload(eventName, eventData) {\r\n  if (ContextDataEvents.has(eventName))\r\n    return ContextDataEvents.get(eventName)(eventData);\r\n\r\n    return {};\r\n}\r\n  \r\n","import EventContextPayload from './eventContextPayload.js';\r\n\r\nexport default EventContext;\r\n\r\n\r\n/**\r\n * Creates a new EventContext object.\r\n *\r\n * @param {function} requestSender - The function used to send requests.\r\n * @param {string} eventName - The name of the event.\r\n * @param {object} eventPayload - An object containing event data.\r\n * @return {object} The new EventContext object.\r\n */\r\nfunction EventContext(requestSender, eventName, eventPayload) {\r\n  const eventData = eventPayload[eventName];\r\n  const contextPayload = EventContextPayload(eventName, eventData);\r\n\r\n  const eventContextResult = new Proxy(eventData, {\r\n    get(target, prop) {\r\n      if (prop in target)\r\n        return target[prop];\r\n\r\n      if (prop === 'update')\r\n        return eventPayload;\r\n\r\n      if (prop === 'payload')\r\n        return contextPayload;\r\n\r\n      return (requestPayload = {}) => requestSender(prop, { ...contextPayload, ...requestPayload });\r\n    },\r\n  });\r\n\r\n  return eventContextResult;\r\n}\r\n\r\n/**\r\n * @callback requestSender - Synchronous function that accepts a method and payload.\r\n * @param {string} method - Telegram API method for the request.\r\n * @param {object} payload - The payload to send with the request.\r\n * @return {Object} - The response from the Telegram API.\r\n */","export default createHandlerStorage;\r\n\r\n/**\r\n * Creates a handler storage object.\r\n *\r\n * @return {Object} The handler storage object with the following methods:\r\n *   - has: a function that checks if a given type has any handlers\r\n *   - get: a function that retrieves the handlers for a given type\r\n *   - add: a function that adds a handler to the storage for a given type\r\n */\r\nfunction createHandlerStorage() {\r\n  const storage = new Map();\r\n\r\n  return {\r\n    has: type => storage.has(type),\r\n    get: type => storage.get(type),\r\n    add(type, value) {\r\n      if (storage.has(type))\r\n        storage.get(type).push(value);\r\n      else\r\n        storage.set(type, [value]);\r\n    }\r\n  };\r\n}","\r\nexport class EventContextError extends Error {\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'EventContextError';\r\n  }\r\n}\r\nexport class BotContextError extends Error {\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'BotContextErrors';\r\n  }\r\n}\r\n\r\n\r\nexport class PayloadValidationError extends Error {\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'PayloadValidationError';\r\n  }\r\n}\r\n\r\n\r\nexport class ResponseError extends Error {\r\n  constructor(code, message) {\r\n    super(message);\r\n    this.code = code;\r\n    this.name = 'ResponseError';\r\n  }\r\n}","import EventContext from './EventContext.js';\r\nimport createHandlerStorage from '../utils/createHandlerStorage.js';\r\nimport { BotContextError } from './errors.js';\r\n\r\nexport default BotContext;\r\n\r\n/**\r\n * Creates a BotContext object that handles event handling and processing.\r\n *\r\n * @param {requestSender} requestSender - Function that accepts a method and payload.\r\n * @param {object} params - Optional parameters.\r\n * @param {string} params.match_separator - The separator used for event matching. Default is '::'.\r\n * @return {object} The BotContext object.\r\n */\r\nfunction BotContext(requestSender, params = {}) {\r\n  const EVENTS = createHandlerStorage();\r\n  const self = {};\r\n\r\n  /**\r\n   * Attaches an event handler for a specific event or event match.\r\n   *\r\n   * @param {string|function} eventName - The event or event match to attach the handler to.\r\n   * @param {function} eventHandler - The handler function to attach.\r\n   */\r\n  self.on = (eventName, eventHandler) => {\r\n    if (typeof eventName === 'function') {\r\n      eventHandler = eventName;\r\n      eventName = null;\r\n    }\r\n\r\n    const eventObject = { handler: eventHandler };\r\n    EVENTS.add(eventName, eventObject);\r\n\r\n    return {\r\n      catch(reject) {\r\n        eventObject.reject = reject;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Processes the event payload by sequentially executing all relevant handlers.\r\n   * If a handler throws an error, it is caught and logged, and execution continues with the next handler.\r\n   *\r\n   * @param {object} eventPayload - The payload of the event.\r\n   * @returns {Promise<Array>} A promise that resolves with an array of results from successful handlers, flattened.\r\n   */\r\n  self.setUpdate = async (eventPayload) => {\r\n    const eventName = Object.keys(eventPayload).find(key => key !== 'update_id');\r\n    const eventContext = EventContext(requestSender, eventName, eventPayload);\r\n\r\n    const eventObjects = [];\r\n\r\n    if (EVENTS.has(eventName))\r\n      eventObjects.push(...EVENTS.get(eventName));\r\n\r\n    if (EVENTS.has(null))\r\n      eventObjects.push(...EVENTS.get(null));\r\n\r\n    const mapHandler = async ({ handler, reject }) => {\r\n      try {\r\n        return await handler(eventContext, eventName);\r\n      } catch (error) {\r\n        if (reject) \r\n          try {\r\n            return await reject(error, eventContext, eventName);\r\n          } catch (rejectError) {\r\n            console.error('An error occurred within the .catch() handler itself:', rejectError);\r\n            return error; // Return the original error\r\n          }\r\n  \r\n        else\r\n          return error;\r\n      }\r\n    };\r\n\r\n    if (params.parallel === true)\r\n      return Promise.all(eventObjects.map(mapHandler));\r\n\r\n    const results = [];\r\n    for (const eventObject of eventObjects) \r\n      results.push(await mapHandler(eventObject));\r\n    \r\n    return results;\r\n  };\r\n\r\n  const botContextResult = new Proxy(self, {\r\n    get: (target, prop) => target[prop]\r\n      ?? ((requestPayload = {}) => requestSender(prop, requestPayload)),\r\n\r\n    set(target, prop, value) {\r\n      if (prop in target)\r\n        throw new BotContextError(`Can't rewrite method \"${prop}\"`);\r\n\r\n      if (typeof value !== 'function')\r\n        throw new BotContextError(`New method \"${prop}\" must be a function`);\r\n\r\n      target[prop] = value(botContextResult);\r\n      return true;\r\n    },\r\n  });\r\n\r\n  return botContextResult;\r\n}\r\n\r\n/**\r\n * @callback requestSender - Synchronous function that accepts a method and payload.\r\n * @param {string} method - Telegram API method for the request.\r\n * @param {object} payload - The payload to send with the request.\r\n * @return {object} - The response from the Telegram API.\r\n */","import createRequestSender from '../utils/browserRequestSenderAsync.js';\r\nimport BotContext from './BotContext.js';\r\n\r\nexport default createBrowserBot ;\r\n\r\n\r\n/**\r\n * Creates a browser bot with the given token and parameters.\r\n *\r\n * @param {string} token - The token used to authenticate the bot.\r\n * @param {object} params - Additional parameters for the bot (optional).\r\n * @return {BotContext} The created bot context.\r\n */\r\nfunction createBrowserBot(token, params = {}) {\r\n  const requestSender = createRequestSender(token);\r\n  return BotContext(requestSender, params);\r\n}\r\n","import RequestPayloadPrepare from \"./requestPayloadPrepare.js\";\r\n\r\nexport default BrowserRequestSenderSync;\r\n\r\nfunction createRequestSender(token, { timeout = 30000, apiUrl = 'https://api.telegram.org' } = {}) {\r\n  if (!token || typeof token !== 'string') \r\n    throw new Error('Token must be a non-empty string');\r\n\r\n  return function requestSender(method, payload = {}) {\r\n    if (!method || typeof method !== 'string') \r\n      throw new Error('Method must be a non-empty string');\r\n\r\n    const url = `${apiUrl}/bot${token}/${method}`;\r\n    const payloadEntries = Object.entries(payload);\r\n    \r\n    const hasFiles = payloadEntries.some(([key, value]) => {\r\n      if (isFile(value)) return true;\r\n      if (key === 'media' && Array.isArray(value)) {\r\n        return value.some(item => isFile(item?.media));\r\n      }\r\n      return false;\r\n    });\r\n\r\n    const request = hasFiles \r\n      ? buildMultipart(payloadEntries) \r\n      : buildJSON(RequestPayloadPrepare(payloadEntries));\r\n\r\n    return sendRequest(url, request, timeout);\r\n  };\r\n}\r\n\r\nfunction isFile(value) {\r\n  if (!value || typeof value !== 'object') return false;\r\n  return value instanceof Blob || \r\n         value instanceof File ||\r\n         (value.source && (value.source instanceof Blob || value.source instanceof File));\r\n}\r\n\r\nfunction buildJSON(payload) {\r\n  return {\r\n    body: JSON.stringify(payload),\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    }\r\n  };\r\n}\r\n\r\nfunction buildMultipart(payloadEntries) {\r\n  const formData = new FormData();\r\n  const files = [];\r\n  let fileIndex = 0;\r\n\r\n  function processValue(key, value) {\r\n    if (isFile(value)) {\r\n      const name = `file${fileIndex++}`;\r\n      const file = value instanceof Blob || value instanceof File ? value : value.source;\r\n      const filename = value.filename || (value instanceof File ? value.name : 'file');\r\n      files.push({ name, file, filename });\r\n      return `attach://${name}`;\r\n    }\r\n    \r\n    if (key === 'media' && Array.isArray(value)) {\r\n      return value.map(item => {\r\n        if (item && typeof item === 'object' && isFile(item.media)) {\r\n          const name = `file${fileIndex++}`;\r\n          const file = item.media instanceof Blob || item.media instanceof File \r\n            ? item.media \r\n            : item.media.source;\r\n          const filename = item.media.filename || (item.media instanceof File ? item.media.name : 'file');\r\n          files.push({ name, file, filename });\r\n          return { ...item, media: `attach://${name}` };\r\n        }\r\n        return item;\r\n      });\r\n    }\r\n    \r\n    return value;\r\n  }\r\n\r\n  for (const [key, value] of payloadEntries) {\r\n    const processedValue = processValue(key, value);\r\n    const fieldValue = typeof processedValue === 'object' && processedValue !== null\r\n      ? JSON.stringify(processedValue)\r\n      : String(processedValue);\r\n    \r\n    formData.append(key, fieldValue);\r\n  }\r\n\r\n  for (const { name, file, filename } of files) {\r\n    formData.append(name, file, filename);\r\n  }\r\n\r\n  return {\r\n    body: formData,\r\n    headers: {}\r\n  };\r\n}\r\n\r\nfunction sendRequest(url, { body, headers }, timeout) {\r\n  const xhr = new XMLHttpRequest();\r\n  \r\n  xhr.open('POST', url, false); // false = синхронный режим\r\n  xhr.timeout = timeout;\r\n\r\n  for (const [key, value] of Object.entries(headers)) {\r\n    xhr.setRequestHeader(key, value);\r\n  }\r\n\r\n  try {\r\n    xhr.send(body);\r\n\r\n    if (xhr.status >= 200 && xhr.status < 300) {\r\n      const data = JSON.parse(xhr.responseText);\r\n      \r\n      if (data.ok) {\r\n        return data.result;\r\n      }\r\n      \r\n      const error = new Error(data.description || 'API Error');\r\n      error.code = data.error_code;\r\n      throw error;\r\n    }\r\n    \r\n    throw new Error(`HTTP Error: ${xhr.status} ${xhr.statusText}`);\r\n  } catch (error) {\r\n    if (error.name === 'NetworkError' || error.name === 'TimeoutError') {\r\n      throw new Error('Request timeout or network error');\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n","import createRequestSender from '../utils/browserRequestSenderSync.js';\r\nimport BotContext from './BotContext.js';\r\n\r\nexport default createBrowserBot ;\r\n\r\n\r\n/**\r\n * Creates a browser bot with the given token and parameters.\r\n *\r\n * @param {string} token - The token used to authenticate the bot.\r\n * @param {object} params - Additional parameters for the bot (optional).\r\n * @return {BotContext} The created bot context.\r\n */\r\nfunction createBrowserBot(token, params = {}) {\r\n  const requestSender = createRequestSender(token);\r\n  return BotContext(requestSender, params);\r\n}\r\n"],"names":["createRequestSender$1","ContextDataEvents","event","businessHandler","eventContextPayload","eventName","eventData","EventContext","requestSender","eventPayload","contextPayload","EventContextPayload","target","prop","requestPayload","createHandlerStorage","storage","type","value","BotContextError","message","BotContext","params","EVENTS","self","eventHandler","eventObject","reject","key","eventContext","eventObjects","mapHandler","handler","error","rejectError","results","botContextResult","createBrowserBot","token","createRequestSender"],"mappings":"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"}